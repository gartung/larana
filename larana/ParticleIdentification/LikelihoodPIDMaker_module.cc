//////////////////////////////////////////////////////////////////////
// Class:       LikelihoodPIDMaker
// Module Type: analyzer
// File:        LikelihoodPIDMaker_module.cc
//
// Generated at Mon Aug 31 11:27:49 2015 by Andrew Olivier using artmod
// from cetpkgsupport v1_08_06. aoliv23@lsu.edu
////////////////////////////////////////////////////////////////////////

#ifndef LIKELIHOODPIDMAKER_MODULE_CC
#define LIKELIHOODPIDMAKER_MODULE_CC

//Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//ROOT includes
#include "TTree.h"
#include "TH1D.h"
#include "TH2D.h"

//LArSoft includes
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larana/TruthMatching/TrajectoryInterpExtrapAlg.h"
#include "larana/TruthMatching/BackTrackMatcherAlg.h"
#include "larana/TruthMatching/StartPosDirMatcherAlg.h"

//c++ includes
#include <map>
#include <algorithm>

namespace pid {

  class LikelihoodPIDMaker : public art::EDAnalyzer {
  public:
    explicit LikelihoodPIDMaker(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
  
    // Plugins should not be copied or assigned.
    LikelihoodPIDMaker(LikelihoodPIDMaker const &) = delete;
    LikelihoodPIDMaker(LikelihoodPIDMaker &&) = delete;
    LikelihoodPIDMaker & operator = (LikelihoodPIDMaker const &) = delete;
    LikelihoodPIDMaker & operator = (LikelihoodPIDMaker &&) = delete;
  
    // Required functions.
    void analyze(art::Event const & e) override;

    //virtual void beginRun(const art::Run& run) override; //This function is a good place to get detector constants that can change between runs

    virtual void beginJob() override;

    virtual void reconfigure(fhicl::ParameterSet const & p);  
  
  private:

    // Declare member data here.
    //I am not going to delete histogram pointers because I think ROOT owns them once they are created by TFileService.
    //Now using vectors of maps: one map for each plane in the TPC (if you have multiple TPCs, this module needs to be reworked)
    std::vector<std::map<int, TH1D*>> fdEdxHists; //maps of PDG code to histogram of all dE/dx values
    std::vector<std::map<int, TH2D*>> fdEdXVsRangeHists; //maps of PDG code to histogram of dE/dx value 
    std::vector<std::map<int, TH1D*>> fNumdEdxPts; //maps of PDG code to histogram of the number of dE/dx points in each calorimetry object
    TH1D* fNumCaloObjects; //histogram of the number of calorimetry objects per track
    TH1D* fXVertex;
    TH1D* fYVertex;
    TH1D* fZVertex;
    TH1D* fEVertex; 
    TH1D* fPVertex;

    TH1D* fNTrack; //Number of reconstructed tracks in each event

    TH1D* fPrimEndProc; //Processes by which secondary particles are produced
    TH2D* fPrimEndProcEn; //2D histogram of end process versus end energy

    TH1D* fSecondaries; //Lists of secondaries from all analyzed primaries
    TH2D* fSecondVsEn;  //Lists of secondaries versus primary end energies for all analyzed primaries

    art::InputTag fCaloTag; //tag of the module that produced anab::Calorimetry objects
    art::InputTag fTrackTag; //tag of the module that produced recob::Track objects
    art::InputTag fAssnTrkHitTag; //tag of the module that produced art::Assns<recob::Track,recob::Hit>
    art::InputTag fAssnTrkVrtxTag; //tag of the module that produced art::Assns<recob::Vertex,recob::Track>
                                  //usually the same as the one that produced recob::Track
    art::InputTag fPIDTag; //tag of the module that produced anab::ParticleID objects
    art::InputTag fTruthTag; //tag of the module that produced simb::MCParticle objects

    size_t fNPlanes;

    double fPosCut; 
    double fAngCut;

    double fMaxX; // of TPC(s)
    double fMaxY;
    double fMaxZ;
    double fMinX;
    double fMinY;
    double fMinZ;

    bool fPrimOnly; //if true, only create likelihood for primary particles
    bool fContained; //Required that primaries' ends are contained for analysis
    bool fContainedStart; //Required that primaries' starting points are contained for analysis

    unsigned int fdEdxProfNBins;
    double fdEdxProfMax;

    double fNdEdxBins;
    double fdEdxMax;

    double fXMargin; //position "margins" in cm: cut particles that are not inside the TPC by these margins
    double fYMargin; 
    double fZMargin;

    bool fOldTruthMatching;
    bool fBackTrackMatching;
    float fMinHitPur;
    float fMinHitEnergyPur;
    float fMaxAngleDeg;
    float fMaxDistToVertex;


    //////////////////////////////
    // Each entry in the tree is a track
    // Each entry in the vector is a calo hit
    TTree* fTree; //tree to hold dEdx and residual range
    TTree* fTree_alltruth; //tree non-vector truth vals even for unmatched true trajectories
    std::vector<float> fTree_resRange;
    std::vector<float> fTree_pitchCorr;
    std::vector<float> fTree_dEdx_raw;
    std::vector<float> fTree_dEdx_pitchCorr;
    std::vector<UInt_t> fTree_plane;
    std::vector<float> fTree_interpE;
    std::vector<float> fTree_interpP;
    std::vector<float> fTree_interpDistance;
    std::vector<UInt_t> fTree_interpIClosestTrajPoint;
    std::vector<float> fTree_interpDistanceToClosestTrajPoint;
    float fTree_KE;
    Int_t fTree_pdg;
    UInt_t fTree_nCaloHits;
    float fTree_startPosX;
    float fTree_startPosY;
    float fTree_startPosZ;
    float fTree_endPosX;
    float fTree_endPosY;
    float fTree_endPosZ;
    float fTree_trkCurvyness;
    float fTree_matchStartDistance;
    float fTree_matchStartAngle;
    float fTree_matchEndDistance;
    float fTree_matchEndAngle;
    Int_t fTree_producesNTracks;

    // Each entry in the vector is a trajectory point
    std::vector<float> fTree_true_resRange;
    std::vector<float> fTree_true_dEdx;
    std::vector<float> fTree_true_trajE;
    std::vector<float> fTree_true_trajp;
    std::vector<bool> fTree_true_inTPC;
    std::vector<UInt_t> fTree_true_trajProcIs;
    std::vector<std::string> fTree_true_trajProcNames;
    // The below are kept even if no match in the second tree
    UInt_t fTree_nTruePoints;
    float fTree_true_ELostInTPC;
    float fTree_true_E;
    float fTree_true_p;
    float fTree_true_thetaZenith;
    float fTree_true_thetaYZ;
    float fTree_true_thetaYX;
    float fTree_true_startPosX;
    float fTree_true_startPosY;
    float fTree_true_startPosZ;
    float fTree_true_endPosX;
    float fTree_true_endPosY;
    float fTree_true_endPosZ;
    float fTree_true_length;
    std::string fTree_true_process;
    std::string fTree_true_endProcess;
    bool fTree_true_startContained;
    bool fTree_true_endContained;
    //////////////////////////////

    art::Ptr<recob::Track> MatchTrack(const simb::MCParticle& truePart, std::vector<art::Ptr<recob::Track>>& recoVect, art::Event const& event);
                                                                                                     //to truth from recoVect.  Returns an invalid art::Ptr
                                                                                                     //if no reco tracks pass the Chi Squared cut.  
                                                                                                     //Removes the matched track, if any, from recoVect

    bool IsInTPC(const TVector3& pos); //check whether a position is inside the TPC
 
    void truthAnalyzer(const simb::MCParticle& truth);

    int producesNTracks(const art::Ptr<recob::Track>& track, const art::Event& event);

    int fPDG; //PDG code of particle to be analyzed; 0 analyzes all particles

    double fMaxEndEn; //maximum end energy at end of TPC

    bool fWriteTree; // writes the tree or not to the TFileService
    bool fWriteTrueTree; // writes truth values to the tree or not. Does not override fWriteTree

  };

  bool LikelihoodPIDMaker::IsInTPC(const TVector3& pos) 
  { 
    return (pos.X() > fMinX && pos.X() < fMaxX 
         && pos.Y() > fMinY && pos.Y() < fMaxY 
         && pos.Z() > fMinZ && pos.Z() < fMaxZ);
  }

  art::Ptr<recob::Track> LikelihoodPIDMaker::MatchTrack(const simb::MCParticle& truePart, std::vector<art::Ptr<recob::Track>>& recoVect, art::Event const& event)
  {
    auto truth = truePart.Trajectory();
    auto vertex = truth.begin();
    while(vertex != truth.end() && !IsInTPC(vertex->first.Vect())) vertex++;
    if(vertex == truth.end()) return art::Ptr<recob::Track>(); //return invalid pointer if no vertex in TPC

    fXVertex->Fill(vertex->first.X());
    fYVertex->Fill(vertex->first.Y());
    fZVertex->Fill(vertex->first.Z());
    fEVertex->Fill(vertex->second.E());
    fPVertex->Fill(vertex->second.Vect().Mag()); //Just momentum 3-vector magnitude

    if(fOldTruthMatching)
    {
      auto bestMatch = recoVect.end();
      double bestProxB = fPosCut; 
      //double bestProxE = fPosCut; 
      double bestAngB = fAngCut;
      //double bestAngE = fAngCut;
      for(auto reco = recoVect.begin(); reco != recoVect.end(); reco++)
      {
        double proxB = (vertex->first.Vect()-(*reco)->LocationAtPoint(0)).Mag2();
        double angCosB = 1-vertex->second.Vect().Unit().Dot((*reco)->DirectionAtPoint(0));
        //double proxE = (vertex->first.Vect()-(*reco)->LocationAtPoint((*reco)->NumberTrajectoryPoints()-1)).Mag2();
        //double angCosE = 1-vertex->second.Vect().Unit().Dot(-((*reco)->DirectionAtPoint((*reco)->NumberTrajectoryPoints()-1)));
        //if( (proxB< bestProxB) && (angCosB<bestAngB)
        //    && (proxE< bestProxE) && (angCosE<bestAngE) )
        //{
        //  bestProxB = proxB;
        //  bestAngB = angCosB;
        //  bestProxE = proxE;
        //  bestAngE = angCosE;
        //  bestMatch = reco;
        //}
        if( (proxB< bestProxB) && (angCosB<bestAngB) )
        {
          bestProxB = proxB;
          bestAngB = angCosB;
          bestMatch = reco;
        }
      } //loop over recob::Tracks

      if(bestMatch != recoVect.end())
      {
        auto retVal = *bestMatch; 
        return retVal;
      } //take matched track out of track vector, then return best match
      return art::Ptr<recob::Track>(); //return an invalid art::Ptr
    } // if fOldTruthMatching
    else if(fBackTrackMatching)
    {
      mctrue::BackTrackMatcherAlg btma;
      float hitEff;
      float hitEnergyEff;
      auto matchedTracks = btma.getMatched(truePart,recoVect,event,fAssnTrkHitTag,fMinHitPur,fMinHitEnergyPur,hitEff,hitEnergyEff);
      if (matchedTracks.size() == 0)
      {
        return art::Ptr<recob::Track>(); //return an invalid art::Ptr
      }
      auto sortedMatchedTracks = btma.sortByDistToMCParticleStart(truePart,matchedTracks,event,fAssnTrkHitTag);
      art::Ptr<recob::Track> result = sortedMatchedTracks[0];
      return result;
    } // if fBackTrackMatching
    else
    {
      mctrue::StartPosDirMatcherAlg spdMatcher;
      art::Ptr<recob::Track> result = spdMatcher.getBestMatch(truePart,recoVect,fMaxAngleDeg);
      return result;
    } // else
  }
  
  LikelihoodPIDMaker::LikelihoodPIDMaker(fhicl::ParameterSet const & p)
    :
    EDAnalyzer(p)
   // More initializers here.
  {
    this->reconfigure(p);
  }

  void LikelihoodPIDMaker::beginJob()
  {
    art::ServiceHandle<geo::Geometry> geom;
    //set up histograms and geometric constants here
    fMaxX = -1e9;
    fMaxY = -1e9;
    fMaxZ = -1e9;
    fMinX = 1e9;
    fMinY = 1e9;
    fMinZ = 1e9;
    for(auto& tpc: geom->IterateTPCs())
    {
      fMaxX = std::max(fMaxX,tpc.MaxX());
      fMaxY = std::max(fMaxY,tpc.MaxY());
      fMaxZ = std::max(fMaxZ,tpc.MaxZ());
      fMinX = std::min(fMinX,tpc.MinX());
      fMinY = std::min(fMinY,tpc.MinY());
      fMinZ = std::min(fMinZ,tpc.MinZ());
      mf::LogWarning("LikelihoodPIDMaker: ") << " TPC NPlanes: "<< tpc.Nplanes() <<" width: "<<2*tpc.HalfWidth()<<"\n";
    }
    fMaxX -= fXMargin;
    fMaxY -= fYMargin;
    fMaxZ -= fZMargin;
    fMinX += fXMargin;
    fMinY += fYMargin;
    fMinZ += fZMargin;
    fNPlanes = geom->MaxPlanes();

    art::ServiceHandle<art::TFileService> tfs;

    for(size_t pIt = 0; pIt < fNPlanes; ++pIt)
    {
      fdEdxHists.push_back(std::map<int, TH1D*>());
      fdEdXVsRangeHists.push_back(std::map<int, TH2D*>());
      fNumdEdxPts.push_back(std::map<int, TH1D*>());
      std::string sPIt = std::to_string(pIt);
    } //loop over planes in this detector
    fNumCaloObjects = tfs->make<TH1D>("numcaloobjects", ";Number of Calorimetry Objects per recob::Track Object;", 10, 0, 10);
    fXVertex = tfs->make<TH1D>("xvertex", ";Matched True Vertex X Positions in cm;", 300, fMinX,fMaxX);
    fYVertex = tfs->make<TH1D>("yvertex", ";Matched True Vertex Y Positions in cm;", 300, fMinY,fMaxY);
    fZVertex = tfs->make<TH1D>("zvertex", ";Matched True Vertex Z Positions in cm;", 300, fMinZ,fMaxZ);
    fEVertex = tfs->make<TH1D>("evertex", ";Matched True Vertex E Values in GeV;", 800, 0, 1.500);
    fPVertex = tfs->make<TH1D>("pvertex", ";Matched True Vertex P Values in GeV/c;", 800, 0, 1.500);
    fNTrack = tfs->make<TH1D>("ntrack", ";Number of Reconstructed Tracks Per Event;", 20, 0, 20);
    fPrimEndProc = tfs->make<TH1D>("primendproc", ";End Processes for Primary Particles;", 10, 0, 10);
    fPrimEndProcEn = tfs->make<TH2D>("primendprocen", ";End Processes;End Energies in MeV;End Processes for Primary Particles Versus Energies;", 10, 0, 10, 800, 0, 1.500);
    fSecondaries = tfs->make<TH1D>("secondaries", ";Secondaries for All Primary Particles;", 10, 0, 10);
    fSecondVsEn = tfs->make<TH2D>("secondvsen", ";Secondary Lists;End Energies in MeV;Lists of Secondaries Versus End Energies;", 10, 0, 10, 800, 0, 1.500);

    if (fWriteTree)
    {
      fTree = tfs->make<TTree>("tree","Tree of dEdx, resRange, etc.");
      fTree->Branch("resRange",&fTree_resRange);
      fTree->Branch("pitchCorr",&fTree_pitchCorr);
      fTree->Branch("dEdx_raw",&fTree_dEdx_raw);
      fTree->Branch("dEdx_pitchCorr",&fTree_dEdx_pitchCorr);
      fTree->Branch("plane",&fTree_plane);

      fTree->Branch("interpE",&fTree_interpE);
      fTree->Branch("interpP",&fTree_interpP);
      fTree->Branch("interpDistance",&fTree_interpDistance);
      fTree->Branch("interpDistanceToClosestTrajPoint",&fTree_interpDistanceToClosestTrajPoint);
      fTree->Branch("interpIClosestTrajPoint",&fTree_interpIClosestTrajPoint);

      fTree->Branch("KE",&fTree_KE,"KE/F");
      fTree->Branch("nCaloHits",&fTree_nCaloHits,"nCaloHits/i");
      fTree->Branch("pdg",&fTree_pdg,"pdg/I");

      fTree->Branch("startPosX",&fTree_startPosX,"startPosX/F");
      fTree->Branch("startPosY",&fTree_startPosY,"startPosY/F");
      fTree->Branch("startPosZ",&fTree_startPosZ,"startPosZ/F");
      fTree->Branch("endPosX",&fTree_endPosX,"endPosX/F");
      fTree->Branch("endPosY",&fTree_endPosY,"endPosY/F");
      fTree->Branch("endPosZ",&fTree_endPosZ,"endPosZ/F");
      fTree->Branch("trkCurvyness",&fTree_trkCurvyness,"trkCurvyness/F");

      fTree->Branch("matchStartDistance",&fTree_matchStartDistance,"matchStartDistance/F");
      fTree->Branch("matchStartAngle",&fTree_matchStartAngle,"matchStartAngle/F");
      fTree->Branch("matchEndDistance",&fTree_matchEndDistance,"matchEndDistance/F");
      fTree->Branch("matchEndAngle",&fTree_matchEndAngle,"matchEndAngle/F");
      fTree->Branch("producesNTracks",&fTree_producesNTracks,"producesNTracks/I");

      if (fWriteTrueTree)
      {
        fTree->Branch("true_resRange",&fTree_true_resRange);
        fTree->Branch("true_dEdx",&fTree_true_dEdx);
        fTree->Branch("true_trajE",&fTree_true_trajE);
        fTree->Branch("true_trajp",&fTree_true_trajp);
        fTree->Branch("true_inTPC",&fTree_true_inTPC);
        fTree->Branch("true_trajProcIs",&fTree_true_trajProcIs);
        fTree->Branch("true_trajProcNames",&fTree_true_trajProcNames);

        fTree_alltruth = tfs->make<TTree>("alltruth","Tree of true particle params, even if not matched to reco track");
        for (auto & tree: {fTree, fTree_alltruth})
        {
          tree->Branch("nTruePoints",&fTree_nTruePoints,"nTruePoints/i");
          tree->Branch("true_ELostInTPC",&fTree_true_ELostInTPC,"true_ELostInTPC/F");
          tree->Branch("true_E",&fTree_true_E,"true_E/F");
          tree->Branch("true_p",&fTree_true_p,"true_p/F");
          tree->Branch("true_thetaZenith",&fTree_true_thetaZenith,"true_thetaZenith/F");
          tree->Branch("true_thetaYZ",&fTree_true_thetaYZ,"true_thetaYZ/F");
          tree->Branch("true_thetaYX",&fTree_true_thetaYX,"true_thetaYX/F");
          tree->Branch("true_startPosX",&fTree_true_startPosX,"true_startPosX/F");
          tree->Branch("true_startPosY",&fTree_true_startPosY,"true_startPosY/F");
          tree->Branch("true_startPosZ",&fTree_true_startPosZ,"true_startPosZ/F");
          tree->Branch("true_endPosX",&fTree_true_endPosX,"true_endPosX/F");
          tree->Branch("true_endPosY",&fTree_true_endPosY,"true_endPosY/F");
          tree->Branch("true_endPosZ",&fTree_true_endPosZ,"true_endPosZ/F");
          tree->Branch("true_length",&fTree_true_length,"true_length/F");
          tree->Branch("true_process",&fTree_true_process);
          tree->Branch("true_endProcess",&fTree_true_endProcess);
          tree->Branch("true_startContained",&fTree_true_startContained,"true_startContained/O");
          tree->Branch("true_endContained",&fTree_true_endContained,"true_endContained/O");
        }

      } // if fWriteTrueTree
    } // if fWriteTree
  }

  void LikelihoodPIDMaker::reconfigure(fhicl::ParameterSet const & p)
  {
    //Get parameters from fcl here
    fCaloTag = p.get<art::InputTag>("CaloTag");
    fPIDTag = p.get<art::InputTag>("PIDTag");
    fTrackTag = p.get<art::InputTag>("TrackTag");
    fAssnTrkHitTag = p.get<art::InputTag>("AssnTrkHitTag");
    fAssnTrkVrtxTag = p.get<art::InputTag>("AssnTrkVrtxTag");
    fTruthTag = p.get<art::InputTag>("TruthTag");
    fPosCut = p.get<double>("PosCut");
    fAngCut = p.get<double>("AngCut");
    fPrimOnly = p.get<bool>("PrimOnly");
    fContained = p.get<bool>("Contained");
    fContainedStart = p.get<bool>("ContainedStart");
    fPDG       = p.get<int>("PDG"); //0=analyze all PDG codes
    fdEdxProfNBins = p.get<unsigned int>("dEdxProfNBins");
    fdEdxProfMax = p.get<double>("dEdxProfMax");
    fMaxEndEn    = p.get<double>("MaxEndEn");
    fNdEdxBins = p.get<double>("NdEdxBins");
    fdEdxMax = p.get<double>("dEdxMax");
    fWriteTree = p.get<bool>("WriteTree");
    fWriteTrueTree = p.get<bool>("WriteTrueTree");
    fOldTruthMatching = p.get<bool>("OldTruthMatching");
    fBackTrackMatching = p.get<bool>("BackTrackMatching");
    fMinHitPur = p.get<float>("MinHitPur");
    fMinHitEnergyPur = p.get<float>("MinHitEnergyPur");
    fMaxAngleDeg = p.get<float>("MaxAngleDeg");
    fXMargin = p.get<double>("XMargin");
    fYMargin = p.get<double>("YMargin");
    fZMargin = p.get<double>("ZMargin");
    fMaxDistToVertex = p.get<float>("MaxDistToVertex");
    if (fOldTruthMatching)
    {
      mf::LogWarning("LikelihoodPIDMaker: ") << " Using OldTruthMatching\n";
    }
    else if(fBackTrackMatching)
    {
      mf::LogWarning("LikelihoodPIDMaker: ") << " Using BackTrackMatcherAlg\n";
    }
    else
    {
      mf::LogWarning("LikelihoodPIDMaker: ") << " Using StartPosDirMatcherAlg\n";
    }
  }
  
  void LikelihoodPIDMaker::analyze(art::Event const & e)
  {
    // Implementation of required member function here.
    // Get handle to TFileService
    art::ServiceHandle<art::TFileService> tfs;
    mctrue::TrajectoryInterpExtrapAlg interpExtrapAlg;

    auto trackHand = e.getValidHandle<std::vector<recob::Track>>(fTrackTag);
    std::vector<art::Ptr<recob::Track>> trackVec;
    art::fill_ptr_vector(trackVec, trackHand); //std::vector<art::Ptr<T>> is much more friendly to FindManyP as used (probably incorrectly) below
    fNTrack->Fill(trackVec.size());

    auto truePartHand = e.getValidHandle<std::vector<simb::MCParticle>>(fTruthTag);

    for(const auto& truth:(*truePartHand))
    {
      if(fPDG && truth.PdgCode() != fPDG) continue;
      if(fPrimOnly && truth.Process() != "primary") continue;
      if(truth.PdgCode() == 22 || truth.PdgCode() == 2112 || truth.PdgCode() == 111 || truth.PdgCode() >= 1e4) continue; //skip particles I am not interested in aoliv23@lsu.edu
      if(truth.EndE()*1000. > fMaxEndEn) continue;
      fTree_true_startContained = IsInTPC(truth.Position().Vect());
      fTree_true_endContained = IsInTPC(truth.EndPosition().Vect());

      // Fill tree with truth info
      if (fWriteTree && fWriteTrueTree)
      {
        truthAnalyzer(truth);
        fTree_alltruth->Fill();
      }

      if(fContained && !fTree_true_endContained) continue;
      if(fContainedStart && !fTree_true_startContained) continue;

      fPrimEndProc->Fill(truth.EndProcess().c_str(), 1.0);
      const auto& lastP = truth.EndMomentum();
      fPrimEndProcEn->Fill(truth.EndProcess().c_str(), (lastP.E()-truth.Mass())*1000., 1.0);

      const auto& recoMatch = MatchTrack(truth, trackVec, e);
      if(recoMatch.isNonnull())
      {
        //std::cout << "Track Size: " << recoMatch->NumberTrajectoryPoints();
        //std::cout << " Track Length: "<< recoMatch->Length() << std::endl;
        //std::cout << "Track Start: ("
        //          << recoMatch->Vertex().X() << ","
        //          << recoMatch->Vertex().Y() << ","
        //          << recoMatch->Vertex().Z() << ")" << std::endl;
        //std::cout << "Track End: ("
        //          << recoMatch->End().X() << ","
        //          << recoMatch->End().Y() << ","
        //          << recoMatch->End().Z() << ")" << std::endl;
        //std::cout << "Track kink angle [deg]: " << std::endl;
        //for (size_t iTrkPnt=1; iTrkPnt < recoMatch->NumberTrajectoryPoints()-1; iTrkPnt++)
        //{
        //  std::cout << " " << iTrkPnt << "  " 
        //    << recoMatch->DirectionAtPoint(iTrkPnt).Angle(recoMatch->DirectionAtPoint(iTrkPnt-1)) * 180/TMath::Pi() << std::endl;;
        //}
        if (fWriteTree)
        {
          fTree_resRange.clear();
          fTree_pitchCorr.clear();
          fTree_dEdx_raw.clear();
          fTree_dEdx_pitchCorr.clear();
          fTree_plane.clear();
          fTree_interpP.clear();
          fTree_interpE.clear();
          fTree_interpDistance.clear();
          fTree_interpDistanceToClosestTrajPoint.clear();
          fTree_interpIClosestTrajPoint.clear();
          fTree_nCaloHits = 0;
          fTree_producesNTracks = producesNTracks(recoMatch,e);
        }

        art::FindManyP<anab::Calorimetry> fmCalo({recoMatch}, e, fCaloTag); //I think I remember reading that constructing FindManyP objects in a loop
                                                                              //is inefficient, but FindManyP objects seem to be incompatible with iterators.  
        int PDG = truth.PdgCode();
        fTree_pdg = PDG;

        fTree_startPosX = recoMatch->Vertex().X();
        fTree_startPosY = recoMatch->Vertex().Y();
        fTree_startPosZ = recoMatch->Vertex().Z();
        fTree_endPosX = recoMatch->End().X();
        fTree_endPosY = recoMatch->End().Y();
        fTree_endPosZ = recoMatch->End().Z();
        fTree_matchStartDistance = (recoMatch->Vertex() - truth.Position(0).Vect()).Mag();
        fTree_matchStartAngle = recoMatch->VertexDirection().Angle(truth.Momentum(0).Vect());
        fTree_matchEndDistance = (recoMatch->End() - truth.EndPosition().Vect()).Mag();
        fTree_matchEndAngle = recoMatch->EndDirection().Angle(truth.EndMomentum().Vect());
        mf::LogInfo("MatchInfo") << "Start Distance: " << fTree_matchStartDistance
                                  << " Start Angle: " << fTree_matchStartAngle
                                  <<" End Distance: " << fTree_matchEndDistance
                                    << " End Angle: " << fTree_matchEndAngle << "\n";

        const std::vector<art::Ptr<anab::Calorimetry> > calos = fmCalo.at(0); //at(0) since only one track was used to make this findManyP object
        fNumCaloObjects->Fill(calos.size()); // number of planes, AFAIK
        for(const auto & calo: calos)
        {
          //const auto& calo = *(fmCalo.at(0).at(cIt)); //at(0) since only one track was used to make this findManyP object
          //size_t plane = calo->PlaneID().Plane;
          const auto plane = calo->PlaneID().Plane;
          const auto& dEdx = calo->dEdx();
          const auto& resRange = calo->ResidualRange();
          const auto& pitch = calo->TrkPitchVec();
          fTree_KE = calo->KineticEnergy();

          const std::vector<TVector3>& caloPosition = calo->XYZ();

          std::string sPDG = std::to_string(PDG); 
          std::string pNum = std::to_string(plane);
          if(plane >= fNPlanes)
          {
            std::string message = "Plane number from calo object is greater than number of planes from geometry.";
            message += "plane: " + std::to_string(plane);
            message += " nPlanes: " + std::to_string(fNPlanes);
            message += " nHits: " + std::to_string(dEdx.size());
            //throw cet::exception("IvalidValue",message);
            mf::LogError("LikelihoodPIDMaker: ") << message << "\n";
            continue;
          }
          if(!fdEdxHists.at(plane)[PDG]) 
          {
            fdEdxHists.at(plane)[PDG] = tfs->make<TH1D>(
                            ("dEdx_pdg"+sPDG+"_plane"+pNum).c_str(), 
                            (";dE/dx in MeV/cm;dE/dx histogram for PDG " 
                                + sPDG+" in Plane "+pNum+";").c_str(), 
                            510, 0, 100
                        );
          }
          if(!fdEdXVsRangeHists.at(plane)[PDG])
          {
            fdEdXVsRangeHists.at(plane)[PDG] = tfs->make<TH2D>(
                            ("pdg"+sPDG+"_plane"+pNum).c_str(), 
                            (";Residual Range in cm;dE/dx in MeV/cm;dE/dx histogram for PDG " + sPDG
                            +" in plane "+pNum+";").c_str(), 
                            fdEdxProfNBins, 0, fdEdxProfMax, fNdEdxBins, 0, fdEdxMax
                        );
          }
          if(!fNumdEdxPts.at(plane)[PDG])
          {
            fNumdEdxPts.at(plane)[PDG] = tfs->make<TH1D>(
                            ("NumdEdxPts_pdg"+sPDG+"_plane"+pNum).c_str(), 
                            (";Number of dEdx Points in each Calorimetry Object for PDG "
                                +sPDG+" in plane "+pNum).c_str(), 
                            100, 0, 100
                        );
          }

          //Do particle identification without small residual range points
          size_t dEdxSize = dEdx.size();
          fNumdEdxPts.at(plane)[PDG]->Fill(dEdxSize);
          mf::LogInfo("TruthInfo") << "True TrackId: " << truth.TrackId() << "\n";
          mf::LogInfo("CaloInfo") << "Calo Plane: " << calo->PlaneID() << "\n";
          for(size_t dEdxIt = 0; dEdxIt < dEdxSize; ++dEdxIt)
          {
            double range = resRange.at(dEdxIt);
            double pitchCorr = pitch[dEdxIt];
            double dEdx_raw = dEdx[dEdxIt];
            double dEdx_pitchCorr = dEdx_raw*pitchCorr;
            fdEdxHists.at(plane)[PDG]->Fill(dEdx_pitchCorr);
            fdEdXVsRangeHists.at(plane)[PDG]->Fill(range, dEdx_pitchCorr);
            mf::LogInfo("dEdxPrint") << "Res Range: " << range 
                << ", dE/dx raw: " << dEdx_raw
                << ", dE/dx pitchCor " << dEdx_pitchCorr
                << ", pitch " << pitchCorr
                << std::endl;
            if (fWriteTree)
            {
              fTree_nCaloHits++;
              fTree_plane.push_back(plane);
              fTree_resRange.push_back(range);
              fTree_pitchCorr.push_back(pitchCorr);
              fTree_dEdx_raw.push_back(dEdx_raw);
              fTree_dEdx_pitchCorr.push_back(dEdx_pitchCorr);
              
              TLorentzVector interpMomentum;
              double interpDistance;
              size_t iClosestTrajPoint;
              double distanceToClosestTrajPoint;
              const TVector3 interpPos = interpExtrapAlg.pointOfClosestApproach(
                                    truth.Trajectory(),
                                    caloPosition[dEdxIt],
                                    interpDistance,
                                    interpMomentum,
                                    iClosestTrajPoint,
                                    distanceToClosestTrajPoint);
              fTree_interpDistance.push_back(interpDistance);
              fTree_interpIClosestTrajPoint.push_back(iClosestTrajPoint);
              fTree_interpDistanceToClosestTrajPoint.push_back(distanceToClosestTrajPoint);
              fTree_interpP.push_back(interpMomentum.Vect().Mag());
              fTree_interpE.push_back(interpMomentum.E());
            } // if fWriteTree
            
          } //loop over calorimetry points
          
        } //loop over calorimetry objects for this track; should be loop over planes...

        // Looking into track topo variables
        fTree_trkCurvyness=0.;
        TVector3 lastPointDir;
        for(size_t iTrkPoints=0; iTrkPoints<recoMatch->NumberTrajectoryPoints(); iTrkPoints++)
        {
          const TVector3& thisPointDir = recoMatch->DirectionAtPoint(iTrkPoints);
          if(iTrkPoints > 0)
          {
            float deltaTheta = thisPointDir.Angle(lastPointDir);
            fTree_trkCurvyness += deltaTheta;
          }
          lastPointDir = thisPointDir;
        } // for iTrkPoints

        fTree->Fill();
      } //if a matching reco track was found for this true particle
    } //loop over true particles
  } //LikelihoodPIDMaker::analyze()

  void LikelihoodPIDMaker::truthAnalyzer(const simb::MCParticle& truth) 
  {
      // reset
      fTree_true_resRange.clear();
      fTree_true_dEdx.clear();
      fTree_true_trajE.clear();
      fTree_true_trajp.clear();
      fTree_true_inTPC.clear();
      fTree_true_trajProcIs.clear();
      fTree_true_trajProcNames.clear();
      fTree_true_ELostInTPC = 0.;
      // Fill MCParticle truth info
      fTree_true_thetaZenith = truth.Momentum().Angle(TVector3(0,1,0));
      fTree_true_thetaYZ = TVector2(truth.Momentum().Z(),truth.Momentum().Y()).Phi();
      fTree_true_thetaYX = TVector2(truth.Momentum().X(),truth.Momentum().Y()).Phi();
      fTree_true_E = truth.Momentum().E();
      fTree_true_p = truth.Momentum().Vect().Mag();
      fTree_true_startPosX = truth.Position().X();
      fTree_true_startPosY = truth.Position().Y();
      fTree_true_startPosZ = truth.Position().Z();
      fTree_true_endPosX = truth.EndPosition().X();
      fTree_true_endPosY = truth.EndPosition().Y();
      fTree_true_endPosZ = truth.EndPosition().Z();
      fTree_true_length = truth.Trajectory().TotalLength();
      fTree_true_process = truth.Process();
      fTree_true_endProcess = truth.EndProcess();
      unsigned nTruePoints = truth.NumberTrajectoryPoints();
      fTree_nTruePoints = nTruePoints;
      float travelledSoFar=0.;
      for(unsigned iTruthPoint=0; iTruthPoint<nTruePoints; iTruthPoint++)
      {
        float dE = 0.;
        float dx = 0.;
        float mdEdx = 0.;
        bool isInTPC = IsInTPC(truth.Position(iTruthPoint).Vect());
        if (iTruthPoint > 0)
        {
          dE = truth.Momentum(iTruthPoint).E() - truth.Momentum(iTruthPoint-1).E();
          dx = (truth.Position(iTruthPoint).Vect() - truth.Position(iTruthPoint-1).Vect()).Mag();
          mdEdx = - dE/dx;
        }
        //else
        //{
        //  dE = truth.Momentum(iTruthPoint+1).E() - truth.Momentum(iTruthPoint).E();
        //  dx = (truth.Position(iTruthPoint+1).Vect() - truth.Position(iTruthPoint).Vect()).Mag();
        //}
        travelledSoFar += dx;
        fTree_true_dEdx.push_back(mdEdx);
        fTree_true_trajE.push_back(truth.Momentum(iTruthPoint).E());
        fTree_true_trajp.push_back(truth.Momentum(iTruthPoint).Vect().Mag());
        fTree_true_inTPC.push_back(isInTPC);
        fTree_true_resRange.push_back(fTree_true_length - travelledSoFar);
        if (isInTPC)
        {
          fTree_true_ELostInTPC -= dE;
        }
      } // for iTruthPoint

      // Investigate trajectoryProcess
      const auto & trajectory = truth.Trajectory();
      const size_t trajectorySize = trajectory.size();
      //std::cout << "Trajectory Size: " << trajectorySize << std::endl;
      //std::cout << "Trajectory Start: ("
      //          << trajectory.X(0) << ","
      //          << trajectory.Y(0) << ","
      //          << trajectory.Z(0) << ")" << std::endl;
      //std::cout << "Trajectory End: ("
      //          << trajectory.X(trajectorySize-1) << ","
      //          << trajectory.Y(trajectorySize-1) << ","
      //          << trajectory.Z(trajectorySize-1) << ")" << std::endl;
      //std::cout << "Trajectory Length: " << totalResRange << std::endl;
      //std::cout << "Intitial Momentum: " << trajectory.Momentum(0).Vect().Mag();
      //std::cout << " End Momentum: " << trajectory.Momentum(trajectorySize-1).Vect().Mag() << std::endl;
      //std::cout << "Process: " << truth.Process() << " EndProcess: " << truth.EndProcess() << std::endl;
      auto trajectoryProcessMap = trajectory.TrajectoryProcesses();
      for(const auto & trajProc: trajectoryProcessMap)
      {
        if (trajProc.first == trajectorySize-1)
        {
          continue;
        }
        //std::cout <<"    "<< trajProc.first<<"  "<< trajProc.second <<"  "<< trajectory.KeyToProcess(trajProc.second);
        //std::cout << " Location: ("
        //          << trajectory.X(trajProc.first) << ","
        //          << trajectory.Y(trajProc.first) << ","
        //          << trajectory.Z(trajProc.first) << ")" 
        //          << " dist to start: " 
        //          << (trajectory.Position(trajProc.first).Vect() - trajectory.Position(0).Vect()).Mag()
        //          << " dist to end: " 
        //          << (trajectory.Position(trajProc.first).Vect() - trajectory.Position(trajectorySize-1).Vect()).Mag()
        //          << std::endl;
        fTree_true_trajProcIs.push_back(trajProc.first);
        fTree_true_trajProcNames.push_back(trajectory.KeyToProcess(trajProc.second));
      }
      // Investigate kinks in trajectory
      //std::cout << "Traj kink angle at point [deg]:" << std::endl;
      //for (size_t iTraj = 0; iTraj < trajectorySize; iTraj++)
      //{
      //  if (iTraj == 0)
      //  {
      //    continue;
      //  }
      //  const TVector3 thisDir = trajectory.Momentum(iTraj).Vect();
      //  const TVector3 lastDir = trajectory.Momentum(iTraj-1).Vect();
      //  double kinkAngle = thisDir.Angle(lastDir);
      //  std::cout << "  " << iTraj << "  " << kinkAngle*180/TMath::Pi() << std::endl;
      //}
  } // LikelihoodPIDMaker::truthAnalyzer

  int LikelihoodPIDMaker::producesNTracks(const art::Ptr<recob::Track>& track, const art::Event& event)
  {
    int result = 0;
    art::FindManyP<recob::Vertex> fmVtx({track}, event, fAssnTrkVrtxTag);
    const std::vector<art::Ptr<recob::Vertex> > vertices = fmVtx.at(0); //at(0) since only one track was used to make this findManyP object
    const TVector3 & trackEndPoint = track->End();
    auto trackEndVertex = vertices.end();
    double vertexDistanceToTrackEnd = fMaxDistToVertex;
    TVector3 trackEndVertexPosition;
    for(std::vector<art::Ptr<recob::Vertex> >::const_iterator vertex = vertices.begin(); vertex != vertices.end(); vertex++)
    {
      double vertexPosArr[3];
      (*vertex)->XYZ(vertexPosArr);
      const TVector3 vertexPos(vertexPosArr[0],vertexPosArr[1],vertexPosArr[2]);
      const double distanceToVertex = (vertexPos - trackEndPoint).Mag();
      if (distanceToVertex < vertexDistanceToTrackEnd)
      {
        vertexDistanceToTrackEnd = distanceToVertex;
        trackEndVertex = vertex;
        trackEndVertexPosition = vertexPos;
      }
    }
    if (trackEndVertex != vertices.end())
    {
      art::FindManyP<recob::Track> fmTrk({*trackEndVertex}, event, fAssnTrkVrtxTag);
      const std::vector<art::Ptr<recob::Track> > vertexTracks = fmTrk.at(0);
      for (const auto& vertexTrack: vertexTracks)
      {
        if(vertexTrack->ID() == track->ID())
        {
          continue;
        }
        double trackStartVertexDistance = (vertexTrack->Vertex() - trackEndVertexPosition).Mag();
        if(trackStartVertexDistance < fMaxDistToVertex)
        {
          result += 1;
        }
      }
    }
    return result;
  } // LikelihoodPIDMaker::producesNTracks

} //namespace LikelihoodPIDMaker

DEFINE_ART_MODULE(pid::LikelihoodPIDMaker)
#endif
