////////////////////////////////////////////////////////////////////////
// Class:       LikelihoodPID
// Module Type: producer
// File:        LikelihoodPID_module.cc
// Brief:       Try to identify a particle as a proton, pion, muon, or kaon using a likelihood ratio test.  
//
// Generated at Mon May 16 14:29:18 2016 by Andrew Olivier using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

//Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "cetlib/exception.h"

//LArIAT includes
#include "larana/ParticleIdentification/LikelihoodAlg.h"

//LArSoft includes
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"

//c++ includes
#include <memory>
#include <algorithm>
#include <map>

#ifndef LIKELIHOODPID_MODULE_CC
#define LIKELIHOODPID_MODULE_CC

namespace pid {
  class LikelihoodPID;
}

class pid::LikelihoodPID : public art::EDProducer {
public:
  explicit LikelihoodPID(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LikelihoodPID(LikelihoodPID const &) = delete;
  LikelihoodPID(LikelihoodPID &&) = delete;
  LikelihoodPID & operator = (LikelihoodPID const &) = delete;
  LikelihoodPID & operator = (LikelihoodPID &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  std::unique_ptr<pid::LikelihoodAlg> fLikeAlg; //algorithm for calculating likelihood ratios for dE/dx vs. residual range
  art::InputTag fTrackLabel;                   //input tag for tracks we will use
  art::InputTag fCaloLabel;                   //input tag for calo objects we will use
  double      fLikelihoodRatioCut;         //Likelihood ratio between largest two likelihoods must be larger than this value to produce an anab::ParticleID 
                                           //object

};


pid::LikelihoodPID::LikelihoodPID(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  reconfigure(p);

  // Call appropriate produces<>(instanceNameString) functions here.
  produces<std::vector<anab::ParticleID> >();
  produces<art::Assns<recob::Track, anab::ParticleID > >();
}

void pid::LikelihoodPID::produce(art::Event & e)
{
  // Implementation of required member function here.
  std::unique_ptr<std::vector<anab::ParticleID> > pidCol(new std::vector<anab::ParticleID>());
  std::unique_ptr<art::Assns<recob::Track, anab::ParticleID > > trackAssns(new art::Assns<recob::Track, anab::ParticleID>());

  auto trackHand = e.getValidHandle<std::vector<recob::Track>>(fTrackLabel);
  std::vector<art::Ptr<recob::Track>> trackPVec; 
  fill_ptr_vector(trackPVec, trackHand);
  auto findManyCalosPForTracks = art::FindManyP<anab::Calorimetry>(trackHand,e,fCaloLabel);
  size_t nTracks = trackPVec.size();
  if (nTracks != findManyCalosPForTracks.size())
  {
    throw cet::exception("LikelihoodPID:VectorSizeDiff") << "trackPVec size:  " << trackPVec.size() << "findManyCalosPForTracks size: " << findManyCalosPForTracks.size() << " must be the same\n";
  }
  std::vector<int> PDGs = fLikeAlg->getPDGs();

  for (size_t iTrack = 0; iTrack < nTracks; iTrack++)
  {
    const std::vector<art::Ptr<anab::Calorimetry>>& calos = findManyCalosPForTracks.at(iTrack);
    for (const auto& calo: calos)
    {
      const std::map<int,double> thisLikelihood = fLikeAlg->CalcLikelihood(*calo); // already log
      const auto mostLikeleyItr = std::max_element(thisLikelihood.begin(), 
                                                  thisLikelihood.end(), 
                                              [](const auto& first, const auto& second)
                                              { return first.second<second.second; }
                                      );
      // Find log likelihoods for the proton, kaon, pion, muon if they were checked
      double protonLLH = 0.;
      double kaonLLH = 0.;
      double pionLLH = 0.;
      double muonLLH = 0.;
      const auto proton = thisLikelihood.find(2212);
      if(proton != thisLikelihood.end())
      {
        protonLLH = proton->second;
      }
      const auto kaonPlus = thisLikelihood.find(321);
      const auto kaonMinus = thisLikelihood.find(-321);
      if(kaonPlus != thisLikelihood.end())
      {
        kaonLLH = kaonPlus->second;
      }
      else if(kaonMinus != thisLikelihood.end())
      {
        kaonLLH = kaonMinus->second;
      }
      const auto pionPlus = thisLikelihood.find(211);
      const auto pionMinus = thisLikelihood.find(-211);
      if(pionPlus != thisLikelihood.end())
      {
        pionLLH = pionPlus->second;
      }
      else if(pionMinus != thisLikelihood.end())
      {
        pionLLH = pionMinus->second;
      }
      const auto muonPlus = thisLikelihood.find(-13);
      const auto muonMinus = thisLikelihood.find(13);
      if(muonPlus != thisLikelihood.end())
      {
        muonLLH = muonPlus->second;
      }
      else if(muonMinus != thisLikelihood.end())
      {
        muonLLH = muonMinus->second;
      }
      // Now find most likeley PID
      if (mostLikeleyItr != thisLikelihood.end()) // greatest found
      {
        std::map<int,double> withoutBestLikelihood;
        for (const auto& llh: thisLikelihood)
        {
          if(llh.first != mostLikeleyItr->first)
          {
            withoutBestLikelihood.emplace(llh.first,llh.second);
          }
        }
        const auto secondMostLikeleyItr = std::max_element(withoutBestLikelihood.begin(), 
                                                  withoutBestLikelihood.end(), 
                                              [](const auto& first, const auto& second)
                                              { return first.second<second.second; }
                                      );
        double deltaLLH = 0.;
        if (secondMostLikeleyItr != withoutBestLikelihood.end())
        {
          deltaLLH = mostLikeleyItr->second - secondMostLikeleyItr->second;
        }
        pidCol->push_back(anab::ParticleID(mostLikeleyItr->first,0,
                                mostLikeleyItr->second,deltaLLH,protonLLH,kaonLLH,pionLLH,muonLLH,
                                        0.,0.,0.,calo->PlaneID()));
      } // greatest LLH found
      else // greatest LLH not found
      {
        pidCol->push_back(anab::ParticleID());
      } // greatest LLH not found
      // by default assoc's the last element of pidCol with given track:
      util::CreateAssn(*this, e, *pidCol, trackPVec[iTrack] , *trackAssns);
    } // for calo
  } // for iTrack
  e.put(std::move(pidCol));
  e.put(std::move(trackAssns));
}

void pid::LikelihoodPID::beginJob()
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::beginSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::endJob()
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::endRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::endSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fLikeAlg.reset(new pid::LikelihoodAlg(p.get<fhicl::ParameterSet>("LikelihoodPIDAlg"))); //(re-)initialize likelihood algorithm
                                        //Among many other functions, PDFs are searched for and normalized here.
                                        //By convention in this module, the PDFs must be named pion, proton, muon, and kaon

  fCaloLabel = p.get<art::InputTag>("CaloLabel");
  fTrackLabel = p.get<art::InputTag>("TrackLabel");
  fLikelihoodRatioCut = p.get<double>("LikelihoodRatioCut", 0);

}

void pid::LikelihoodPID::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void pid::LikelihoodPID::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(pid::LikelihoodPID)
#endif
