/////////////////////////////////////////////////////////////////////
///  Class:       MCParticlePFParticleMatching
///  Module Type: producer
///  File:        MCParticlePFParticleMatching_module.cc
///  Author:      Yun-Tse Tsai
///  E-mail:      yuntse@slac.stanford.edu
///
///
///  Input:
///  Output:
///
/////////////////////////////////////////////////////////////////////

// Framework includes
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>

// LArSoft
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Shower.h"

#include "lardata/Utilities/AssociationUtil.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"

namespace t0 {
  class MCParticlePFParticleMatching;
}

class t0::MCParticleShowerMatching : public art::EDProducer {
public:
  explicit MCParticleShowerMatching(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  //
  // Plugins should not be copied or assigned.
  MCParticleShowerMatching(MCParticleShowerMatching const &) = delete;
  MCParticleShowerMatching(MCParticleShowerMatching &&) = delete;
  MCParticleShowerMatching & operator = (MCParticleShowerMatching const &) = delete;
  MCParticleShowerMatching & operator = (MCParticleShowerMatching &&) = delete;
  
  // Required functions.
  void produce(art::Event & e) override;
  
  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  
  
  private:
  
  art::InputTag fShowerModuleLabel;
  art::InputTag fShowerHitAssnLabel;
  art::InputTag fHitModuleLabel;
  art::InputTag fHitParticleAssnLabel;
  
};


t0::MCParticleShowerMatching::MCParticleShowerMatching(fhicl::ParameterSet const & p)
{
  reconfigure(p);
  produces< art::Assns<recob::Shower , simb::MCParticle, anab::BackTrackerMatchingData > > ();
}

void t0::MCParticleShowerMatching::reconfigure(fhicl::ParameterSet const & p)
{
  fShowerModuleLabel = p.get<art::InputTag>("ShowerModuleLabel");
  fShowerHitAssnLabel = p.get<art::InputTag>("ShowerHitAssnLabel",fShowerModuleLabel);
  fHitModuleLabel = p.get<art::InputTag>("HitModuleLabel");
  fHitParticleAssnLabel = p.get<art::InputTag>("HitParticleAssnLabel");

}

void t0::MCParticleShowerMatching::beginJob()
{
}

