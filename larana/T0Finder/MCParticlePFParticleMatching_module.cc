/////////////////////////////////////////////////////////////////////
///  Class:       MCParticlePFParticleMatching
///  Module Type: producer
///  File:        MCParticlePFParticleMatching_module.cc
///  Author:      Yun-Tse Tsai
///  E-mail:      yuntse@slac.stanford.edu
///
///
///  Input:
///  Output:
///
/////////////////////////////////////////////////////////////////////

// Framework includes
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "canvas/Persistency/Common/PtrVector.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <iterator>

// LArSoft
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/PFParticle.h"

#include "lardata/Utilities/AssociationUtil.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "lardataobj/AnalysisBase/BackTrackerMatchingData.h"

namespace t0 {
   class MCParticlePFParticleMatching;
}

class t0::MCParticlePFParticleMatching : public art::EDProducer {
public:
   explicit MCParticlePFParticleMatching( fhicl::ParameterSet const & p );
   // The destructor generated by the compiler is fine for classes
   // without bare pointers or other resource use.
   //
   // Plugins should not be copied or assigned.
   MCParticlePFParticleMatching( MCParticlePFParticleMatching const & ) = delete;
   MCParticlePFParticleMatching( MCParticlePFParticleMatching && ) = delete;
   MCParticlePFParticleMatching & operator = ( MCParticlePFParticleMatching const & ) = delete;
   MCParticlePFParticleMatching & operator = ( MCParticlePFParticleMatching && ) = delete;
  
   // Required functions.
   void produce( art::Event & e ) override;
  
   // Selected optional functions.
   void beginJob() override;
   void reconfigure( fhicl::ParameterSet const & p ) override;

   std::map< int, simb::MCParticle const* > mapTrackIDToMCParticle( std::vector< simb::MCParticle > const& particles ) const;
   std::vector< int > createHierarchyList( std::map< int, simb::MCParticle const* > const& TrackIDToMCParticle, int trackID ) const; 
  
   private:
  
   art::InputTag fMCParticleLabel;
   art::InputTag fPFParticleLabel;
   art::InputTag fClusterLabel;
   art::InputTag fHitLabel;
   art::InputTag fHitMCParticleAssnLabel;
   art::InputTag fHitClusterAssnLabel;
   art::InputTag fClusterPFParticleAssnLabel;
   bool fIncludeDaughters;
   bool fUseCharge;

   struct MatchingInfo {
      float charges;
      int   nHits;
   };

};


t0::MCParticlePFParticleMatching::MCParticlePFParticleMatching( fhicl::ParameterSet const & p ) {
   reconfigure( p );
   produces< art::Assns< recob::PFParticle , simb::MCParticle, anab::BackTrackerMatchingData > > ();
}

void t0::MCParticlePFParticleMatching::reconfigure( fhicl::ParameterSet const & p ) {
   fMCParticleLabel = p.get< art::InputTag >( "MCParticleModuleLabel" );
   fPFParticleLabel = p.get< art::InputTag >( "PFParticleModuleLabel" );
   fClusterLabel = p.get< art::InputTag >( "ClusterModuleLabel" );
   fHitLabel = p.get< art::InputTag >( "HitModuleLabel" );
   fHitMCParticleAssnLabel = p.get< art::InputTag >( "HitMCParticleAssnLabel" );
   fHitClusterAssnLabel = p.get< art::InputTag >( "HitClusterAssnLabel" );
   fClusterPFParticleAssnLabel = p.get< art::InputTag >( "ClusterPFParticleAssnLabel" );
   fIncludeDaughters = p.get< bool >( "IncludeMCDaughters", false );
   fUseCharge = p.get< bool >( "UseCharge", false );
}

void t0::MCParticlePFParticleMatching::beginJob() {
}

std::map< int, simb::MCParticle const* > t0::MCParticlePFParticleMatching::mapTrackIDToMCParticle( std::vector< simb::MCParticle > const& particles ) const {

   std::map< int, simb::MCParticle const* > TrackIDToMCParticle;
   for ( std::size_t i = 0; i < particles.size(); ++i ) {
      auto const& particle = particles[i];
      TrackIDToMCParticle[particle.TrackId()] = &(particle);
   }
   return TrackIDToMCParticle;
} 

std::vector< int > t0::MCParticlePFParticleMatching::createHierarchyList( std::map< int, simb::MCParticle const* > const& TrackIDToMCParticle, int trackID ) const {

   std::vector< int > TrackIDList;
   simb::MCParticle const& MCPart = *(TrackIDToMCParticle.at(trackID));
   TrackIDList.push_back( MCPart.TrackId() );

   if ( MCPart.NumberDaughters() == 0 ) return TrackIDList;
   else {
      for ( int i = 0; i < MCPart.NumberDaughters(); ++i ) {
         auto const& newTracks = createHierarchyList( TrackIDToMCParticle, MCPart.Daughter(i) );
         TrackIDList.insert( TrackIDList.end(), newTracks.begin(), newTracks.end() );
      }
   }
   return TrackIDList;
}

void t0::MCParticlePFParticleMatching::produce( art::Event & evt ) {

   if ( evt.isRealData() ) return;

   // Recover the MC particles
   auto MCParticleHandle = evt.getValidHandle< std::vector< simb::MCParticle > >( fMCParticleLabel );

   // Recover the PFParticles
   auto PFParticleHandle = evt.getValidHandle< std::vector< recob::PFParticle > >( fPFParticleLabel );

   // Recover the clusters
   auto ClusterHandle = evt.getValidHandle< std::vector< recob::Cluster > >( fClusterLabel );
 
   // Recover the hits
   auto HitHandle = evt.getValidHandle< std::vector< recob::Hit > >( fHitLabel );

   // Retrieve Hit <--> MCParticle association and the metadata
   art::FindManyP< recob::Hit, anab::BackTrackerHitMatchingData > MCParticleHitAssn( MCParticleHandle, evt, fHitMCParticleAssnLabel );

   // Retrieve Hit <--> Cluster association
   art::FindManyP< recob::Cluster > HitClusterAssn( HitHandle, evt, fHitClusterAssnLabel );

   // Retrieve Cluster <--> PFParticle association
   art::FindManyP< recob::PFParticle > ClusterPFParticleAssn( ClusterHandle, evt, fClusterPFParticleAssnLabel );

   // Build a map between trackID and MCParticle
   std::map< int, simb::MCParticle const* > TrackIDToMCParticle = mapTrackIDToMCParticle( *MCParticleHandle );

   std::unique_ptr< art::Assns< simb::MCParticle, recob::PFParticle, anab::BackTrackerMatchingData > > MCPartPFPartAssn( new art::Assns< simb::MCParticle, recob::PFParticle, anab::BackTrackerMatchingData > );

   simb::MCParticle const* firstParticle = &(MCParticleHandle->at(0));
   for ( size_t iMCPart = 0; iMCPart < MCParticleHandle->size(); ++iMCPart ) {

      art::Ptr< simb::MCParticle > mcParticle( MCParticleHandle, iMCPart );

      // Process of the MC particle
      auto Process = mcParticle->Process();

      // At the moment we only care of primary particles for the events generated by a particle gun
      if ( Process != "primary" ) continue;

      std::vector< int > TrackIDList;
      if ( fIncludeDaughters ) {
         TrackIDList = createHierarchyList( TrackIDToMCParticle, mcParticle->TrackId() );
      } else {
         TrackIDList.push_back( mcParticle->TrackId() );
      }

      std::map< size_t, MatchingInfo > MatchedPFParticles;

      for ( size_t iTrackID = 0; iTrackID < TrackIDList.size(); ++iTrackID ) {

         int trackID = TrackIDList[iTrackID];
         simb::MCParticle const* MCPartPtr = TrackIDToMCParticle[trackID];

         size_t mcpartIndex = MCPartPtr - firstParticle;
         auto const& hitPtrs = MCParticleHitAssn.at( mcpartIndex );

         if ( hitPtrs.empty() ) continue;

         for ( auto const& hitPtr : hitPtrs ) {

            auto const& clusterPtrs = HitClusterAssn.at( hitPtr.key() );
            if ( clusterPtrs.empty() ) continue;
            if ( clusterPtrs.size() > 1 ) {
               mf::LogWarning("MCParticlePFParticleMatching") << "===>> More than one Cluster associated to a Hit.";
               continue;
            }

            auto const& clusterPtr = clusterPtrs.front();
            auto const& pfpartPtrs = ClusterPFParticleAssn.at( clusterPtr.key() );
            if ( pfpartPtrs.empty() ) continue;
            if ( pfpartPtrs.size() > 1 ) {
               mf::LogWarning("MCParticlePFParticleMatching") << "===>> More than one PFParticle associated to a Cluster.";
               continue;
            }

            auto const& pfpartPtr = pfpartPtrs.front();
            // Note the charge is possibly not calibrated
            MatchedPFParticles[pfpartPtr.key()].charges += hitPtr->Integral();
            MatchedPFParticles[pfpartPtr.key()].nHits += 1;

         } // for ( auto const& hitPtr : hitPtrs )

      } // for ( size_t iTrackID = 0; iTrackID < TrackIDList.size(); ++iTrackID )

      mf::LogInfo("MCParticlePFParticleMatching") << "===>> " << MatchedPFParticles.size() << " PFParticles are involved with the MCParticle " << iMCPart;

      // Find the best matched PFParticle
      size_t nBestMatchedPFParticle = 0;
      int maxnHits = 0;
      float maxCharges = 0.;
      for ( auto const& ipfp : MatchedPFParticles ) {
         if ( fUseCharge ) {
            if ( ipfp.second.charges > maxCharges ) {
               maxCharges = ipfp.second.charges;
               nBestMatchedPFParticle = ipfp.first;
            }
         } else {
            if ( ipfp.second.nHits > maxnHits ) {
               maxnHits = ipfp.second.nHits;
               nBestMatchedPFParticle = ipfp.first;
            }
         }
      }

      // Fill the matching metadata
      // TODO: Calculate the values
      anab::BackTrackerMatchingData matchingData;
      if ( fUseCharge) {
         matchingData.cleanliness = 0.;
         matchingData.completeness = 0.;
      } else {
         matchingData.cleanliness = 0.;
         matchingData.completeness = 0.;
      }

      art::Ptr< recob::PFParticle > BestMatchedPFParticle( PFParticleHandle, nBestMatchedPFParticle );
      MCPartPFPartAssn->addSingle( mcParticle, BestMatchedPFParticle, matchingData );

   } // for ( size_t iMCPart = 0; iMCPart < MCParticleHandle->size(); ++iMCPart )

   evt.put( std::move( MCPartPFPartAssn ) );
} // Produce

DEFINE_ART_MODULE(t0::MCParticlePFParticleMatching)

