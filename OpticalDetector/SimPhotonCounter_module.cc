// \file SimPhotonCounter.h 
// \author Ben Jones, MIT 2010
//
// Module to determine how many phots have been detected at each OpDet
//
// This analyzer takes the SimPhotonsCollection generated by LArG4's sensitive detectors
// and fills up to four trees in the histograms file.  The four trees are:
//
// OpDetEvents       - count how many phots hit the OpDet face / were detected across all OpDet's per event
// OpDets            - count how many phots hit the OpDet face / were detected in each OpDet individually for each event
// AllPhotons      - wavelength information for each phot hitting the OpDet face
// DetectedPhotons - wavelength information for each phot detected
//
// The user may supply a quantum efficiency and sensitive wavelength range for the OpDet's.
// with a QE < 1 and a finite wavelength range, a "detected" phot is one which is
// in the relevant wavelength range and passes the random sampling condition imposed by
// the quantum efficiency of the OpDet
//
// PARAMETERS REQUIRED:
// int32   Verbosity          - whether to write to screen a well as to file. levels 0 to 3 specify different levels of detail to display
// string  InputModule        - the module which produced the SimPhotonsCollection
// bool    MakeAllPhotonsTree - whether to build and store each tree (performance can be enhanced by switching off those not required)
// bool    MakeDetectedPhotonsTree
// bool    MakeOpDetsTree
// bool    MakeOpDetEventsTree
// double  QuantumEfficiency   - Quantum efficiency of OpDet
// double  WavelengthCutLow   - Sensitive wavelength range of OpDet
// double  WavelengthCutHigh
#ifndef SimPhotonCounter_h
#define SimPhotonCounter_h 1

// ROOT includes.
#include "TTree.h"
#include "TFile.h"
#include <Rtypes.h>

// FMWK includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Persistency/Common/Ptr.h"
#include "art/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes
#include "PhotonPropagation/PhotonVisibilityService.h"
#include "Simulation/SimListUtils.h"
#include "Simulation/sim.h"
#include "Simulation/LArG4Parameters.h"

// ROOT includes
#include <TH1D.h>
#include <TF1.h>
#include <TTree.h>
#include <TVectorT.h>
#include <TAxis.h>

// C++ language includes
#include <iostream>
#include <sstream>
#include <cstring>
#include <vector>

#include "CLHEP/Random/RandFlat.h"
#include "CLHEP/Random/RandGaussQ.h"
int allphotons1=0;
int allphotons2=0;
namespace opdet {

  class SimPhotonCounter : public art::EDAnalyzer{
    public:
      
      SimPhotonCounter(const fhicl::ParameterSet&);
      virtual ~SimPhotonCounter();
      
      void analyze(art::Event const&);
      
      void beginJob();
      void endJob();
     
    private:
      
      // Trees to output

      TTree * fThePhotonTreeAll;
      TTree * fThePhotonTreeDetected;
      TTree * fTheOpDetTree;
      TTree * fTheEventTree;


      // Parameters to read in
	
      std::string fInputModule;      // Input tag for OpDet collection

      int fVerbosity;                // Level of output to write to std::out
	bool fNewDetectorApproach;//to be discarded once the new way of definind detectors is established
	int fDetectorNumber;//total number of photodetectors
	int fDetectorTypes;//number of different types of photodets
      bool fMakeDetectedPhotonsTree; //
      bool fMakeAllPhotonsTree;      //
      bool fMakeOpDetsTree;         // Switches to turn on or off each output
      bool fMakeOpDetEventsTree; 
	bool fDetailedQE;         //
      bool fFill;
      bool fUseQE;
      float fQE; 
	int typedet=0;	
	double fftest;              // Quantum efficiency of tube
      std::vector<double> fQE2H; 
      std::vector<int> fChannelTypes;
      std::vector<double> fQE2E;
      std::vector<double> fQE2Si;    
      std::vector<double> fQEn;                   // Quantum efficiency of tube
      std::vector<std::vector<double>> fDetEff;    
      std::vector<std::vector<double>> fEnEff;
	//Histrograms to store efficiency
	TH1D *QeEnergyHist;
	TH1D *QEHmm;
	TH1D *QEEtl;
	TH1D *QESipm;
	std::vector<TH1D *> QEDets;
      float fWavelengthCutLow;       // Sensitive wavelength range 
      float fWavelengthCutHigh;      // 


      

      // Data to store in trees

      Float_t fWavelength;
      Float_t fTime;
      Int_t fCount;
      Int_t fCountOpDetAll;
      Int_t fCountOpDetDetected;

      Int_t fCountEventAll;
      Int_t fCountEventDetected;
      
      Int_t fEventID;
      Int_t fOpChannel;


    };
}

#endif


namespace opdet {
  

  SimPhotonCounter::SimPhotonCounter(fhicl::ParameterSet const& pset)
    : EDAnalyzer(pset)
  {
    fVerbosity=                pset.get<int>("Verbosity");
    fNewDetectorApproach=      pset.get<bool>("NewDetectorApproach",false);

    fInputModule=              pset.get<std::string>("InputModule");
    fMakeAllPhotonsTree=       pset.get<bool>("MakeAllPhotonsTree");
    fMakeDetectedPhotonsTree=  pset.get<bool>("MakeDetectedPhotonsTree");
    fMakeOpDetsTree=           pset.get<bool>("MakeOpDetsTree");
    fMakeOpDetEventsTree=      pset.get<bool>("MakeOpDetEventsTree");

    fDetailedQE=       pset.get<bool>("QuantumEfficiencyDetails");
    fUseQE=       pset.get<bool>("UsePMTEff");
    fQE=                       pset.get<double>("QuantumEfficiency");
    //channel type map
	if(fDetailedQE){


    fQE2H=                       pset.get< std::vector<double> >("QuantumEfficiencyVectorHmm");
    fQE2E=                       pset.get< std::vector<double> >("QuantumEfficiencyVectorEtl");
    fQE2Si=                       pset.get< std::vector<double> >("QuantumEfficiencyVectorSi"); 
    fQEn=                       pset.get< std::vector<double> >("QuantumEfficiencyEnergies");
	//Double_t qen[10];
	TVectorT<double> qen2(10);
	for(int i=0;i<int(fQEn.size());i++) qen2[i]=fQEn[i];
	
	

	QeEnergyHist=new TH1D(qen2);
	QEHmm=new TH1D(qen2);
	QEEtl=new TH1D(qen2);
	QESipm=new TH1D(qen2);

	for(int j=0;j<10;j++) {
	QEHmm->SetBinContent(j,fQE2H[j]);
	QEEtl->SetBinContent(j,fQE2E[j]);
	QESipm->SetBinContent(j,fQE2Si[j]);
	
	}

		if(fNewDetectorApproach){
   			fDetectorNumber=                pset.get<int>("DetectorNumber", 1);
    			fDetectorTypes=     pset.get<int>("DetectorTypes", 1);
    			fChannelTypes=   pset.get< std::vector<int> >("ChannelTypes");
    			fDetEff=   pset.get< std::vector<std::vector<double>> >("QuantumEfficiencyVector");
    			fEnEff=    pset.get< std::vector<std::vector<double>> >("QuantumEfficiencyEnergiesVector");
				std::vector<TVectorT<double>> qen3;
				qen3.resize(fDetectorTypes);


				for(int j=0;j<fDetectorTypes;j++){
					for(int jj=0;jj<int(fEnEff[j].size());jj++){
						if(jj==0) qen3[j].ResizeTo(int(fEnEff[j].size()));
						qen3[j][jj]=fEnEff[j][jj];
						std::cout<<"setting energy "<<qen3[j][jj]<<std::endl;
						}
					}
	


				for(int j=0;j<fDetectorTypes;j++) {
					QEDets.push_back(new TH1D(qen3[j]));
					for(int ii=0;ii<int(fDetEff[j].size());ii++){
						QEDets[j]->SetBinContent(ii,fDetEff[j][ii]);
					}
				}

			}//new detector approach - discard the previous one and replace with this after the new way of accessing data will work

	}//detailed QE
    fWavelengthCutLow=         pset.get<double>("WavelengthCutLow");
    fWavelengthCutHigh=        pset.get<double>("WavelengthCutHigh");
    // get the random number seed, use a random default if not specified    
    // in the configuration file.  
    unsigned int seed = pset.get< unsigned int >("Seed", sim::GetRandomNumberSeed());
    createEngine(seed);   

 
  }
  

  void SimPhotonCounter::beginJob()
  {
    // Get file service to store trees
    art::ServiceHandle<art::TFileService> tfs;

     // Create and assign branch addresses to required tree
    if(fMakeAllPhotonsTree)
      {
	fThePhotonTreeAll = tfs->make<TTree>("AllPhotons","AllPhotons");
	fThePhotonTreeAll->Branch("EventID",     &fEventID,          "EventID/I");
	fThePhotonTreeAll->Branch("Wavelength",  &fWavelength,       "Wavelength/F");
	fThePhotonTreeAll->Branch("OpChannel",       &fOpChannel,            "OpChannel/I");
	fThePhotonTreeAll->Branch("Time",        &fTime,             "Time/F");
      }

    if(fMakeDetectedPhotonsTree)
      {
	fThePhotonTreeDetected = tfs->make<TTree>("DetectedPhotons","DetectedPhotons");
	fThePhotonTreeDetected->Branch("EventID",     &fEventID,          "EventID/I");
	fThePhotonTreeDetected->Branch("Wavelength",  &fWavelength,       "Wavelength/F");
	fThePhotonTreeDetected->Branch("OpChannel",       &fOpChannel,            "OpChannel/I");
	fThePhotonTreeDetected->Branch("Time",        &fTime,             "Time/F");
      }

    if(fMakeOpDetsTree)
      {
	fTheOpDetTree    = tfs->make<TTree>("OpDets","OpDets");
	fTheOpDetTree->Branch("EventID",        &fEventID,          "EventID/I");
	fTheOpDetTree->Branch("OpChannel",          &fOpChannel,            "OpChannel/I");
	fTheOpDetTree->Branch("CountAll",       &fCountOpDetAll,      "CountAll/I");
	fTheOpDetTree->Branch("CountDetected",  &fCountOpDetDetected, "CountDetected/I");
      }
    
    if(fMakeOpDetEventsTree)
      {
	fTheEventTree  = tfs->make<TTree>("OpDetEvents","OpDetEvents");
	fTheEventTree->Branch("EventID",      &fEventID,            "EventID/I");
	fTheEventTree->Branch("CountAll",     &fCountEventAll,     "CountAll/I");
	fTheEventTree->Branch("CountDetected",&fCountEventDetected,"CountDetected/I");
      }

  }

  
  SimPhotonCounter::~SimPhotonCounter() 
  {
  }
  
  void SimPhotonCounter::endJob()
  {
    art::ServiceHandle<phot::PhotonVisibilityService> vis;
   
    if(vis->IsBuildJob())
      {
	vis->StoreLibrary();
      }
  }

  void SimPhotonCounter::analyze(art::Event const& evt)
  {

    // Setup random number generator (for QE sampling)
    art::ServiceHandle<art::RandomNumberGenerator> rng;
    CLHEP::HepRandomEngine &engine = rng->getEngine();
    CLHEP::RandFlat   flat(engine);

    // Lookup event ID from event
    art::EventNumber_t event = evt.id().event();
    fEventID=Int_t(event);

    art::ServiceHandle<sim::LArG4Parameters> lgp;
    bool fUseLitePhotons = lgp->UseLitePhotons();
    //Reset counters
    fCountEventAll=0;
    fCountEventDetected=0;
    //Reset counters
   fCountOpDetAll=0;
    fCountOpDetDetected=0;
    if(!fUseLitePhotons)
    {
    //Get SimPhotonsCollection from Event
    sim::SimPhotonsCollection TheHitCollection = sim::SimListUtils::GetSimPhotonsCollection(evt,fInputModule);

    //Reset counters
    fCountEventAll=0;
    fCountEventDetected=0;
    allphotons1=0;
	    fCountOpDetAll=0;
	    fCountOpDetDetected=0;
    if(fVerbosity > 0) std::cout<<"Found OpDet hit collection of size "<< TheHitCollection.size()<<std::endl;
    if(TheHitCollection.size()>0)
      {
	for(sim::SimPhotonsCollection::const_iterator itOpDet=TheHitCollection.begin(); itOpDet!=TheHitCollection.end(); itOpDet++)
	  {
	    //Reset Counters
	    fCountOpDetAll=0;
	    fCountOpDetDetected=0;
	    allphotons1=0;

	    //Get data from HitCollection entry
	    fOpChannel=itOpDet->first;
	    const sim::SimPhotons& TheHit=itOpDet->second;
	      
	    	   // std::cout<<"Reseted counters, OpDet channel " << fOpChannel << " has size " << TheHit->size()<<std::endl;
	    
	    // Loop through OpDet phots.  
	    //   Note we make the screen output decision outside the loop
	    //   in order to avoid evaluating large numbers of unnecessary 
	    //   if conditions. 

	    if(fVerbosity > 3) 
	      {


		std::cout<<"was here 311================== verbosity >3 "<<std::endl;
		for(const sim::OnePhoton& Phot: TheHit)
		  {

//std::cout<<"detected photons reset test ---------------------- "<<fCountOpDetDetected<<" channel "<<fOpChannel<<std::endl;
			allphotons1++;
			allphotons2++;
		    // Calculate wavelength in nm
		    fWavelength= (2.0*3.142)*0.000197/Phot.Energy;

		    //Get arrival time from phot
		    fTime= Phot.Time;
			fCountOpDetAll++;
		   // std::cout<<" 305 Arrival time: " << fTime<<std::endl;
		    
		    // Increment per OpDet counters and fill per phot trees
		fFill=false;
//std::cout<<"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% details of QE "<<fDetailedQE<<" "<<fWavelength<<std::endl;
		 
		    if(fMakeAllPhotonsTree) fThePhotonTreeAll->Fill();
		    if((flat.fire(1.0)<=fQE)&&(fWavelength>fWavelengthCutLow)&&(fWavelength<fWavelengthCutHigh))
		      {
		
		if(fUseQE){
		std::cout<<"QE used 321!!!"<<fUseQE<<" wavelengh"<<fWavelengthCutLow<<" "<<fWavelength<<" "<<fWavelengthCutHigh<<std::endl;
		if(fDetailedQE){
			fFill=true;

			if(fNewDetectorApproach){
				fftest=flat.fire(1.0);

				typedet=fChannelTypes[fOpChannel];
				  std::cout<<"channel "<< fOpChannel<<" type "<<typedet<<" energy of photon "<<Phot.Energy/0.000001<<" "<<fftest<<" "<<QEDets[typedet]->GetBinContent(QEDets[typedet]->GetXaxis()->FindBin(Phot.Energy/0.000001))<<std::endl;
				if(fftest>QEDets[typedet]->GetBinContent(QEDets[typedet]->GetXaxis()->FindBin(Phot.Energy/0.000001))) 					fFill=false;
			}
			else{
			switch(fOpChannel){
				case 0:{
				fftest=flat.fire(1.0);
				//  std::cout<<"channel 0 etl"<<" energy of photon "<<Phot.Energy/0.000001<<" "<<fftest<<" "<<QESipm->GetBinContent(QESipm->GetXaxis()->FindBin(Phot.Energy/0.000001))<<std::endl;
				if(fftest>QEEtl->GetBinContent(QEEtl->GetXaxis()->FindBin(Phot.Energy/0.000001))) 					fFill=false;
				break;
				}
				case 1:{
				fftest=flat.fire(1.0);
				 // std::cout<<"channel 1 hmm"<<" energy of photon "<<Phot.Energy/0.000001<<" "<<fftest<<" "<<QEHmm->GetBinContent(QEHmm->GetXaxis()->FindBin(Phot.Energy/0.000001))<<std::endl;
				if(fftest>QEHmm->GetBinContent(QEHmm->GetXaxis()->FindBin(Phot.Energy/0.000001))) 					fFill=false;
				break;
				}
				case 2:{
				fftest=flat.fire(1.0);
				// std::cout<<"channel 2 sipm"<<" energy of photon "<<Phot.Energy/0.000001<<" "<<fftest<<" "<<QEEtl->GetBinContent(QEEtl->GetXaxis()->FindBin(Phot.Energy/0.000001))<<std::endl;
				if(fftest>QESipm->GetBinContent(QESipm->GetXaxis()->FindBin(Phot.Energy/0.000001))) 					fFill=false;
				break;
				}
				case 3:{
				fftest=flat.fire(1.0);
				 // std::cout<<"channel 3 sipm"<<std::endl;
				if(fftest>QESipm->GetBinContent(QESipm->GetXaxis()->FindBin(Phot.Energy/0.000001))) 					fFill=false;
				break;
				}
				default:
				std::cout<<"error"<<std::endl;
			}
			}//old detector approach

		}//QE details

//no qe details
		if(fDetailedQE){
			fFill=true;
			switch(fOpChannel){
				case 0:{
				//fFill=false;
				break;
				}
				case 1:{
				//fFill=false;
				break;
				}
				case 2:{
 				//fFill=false;
				break;
				}
				case 3:{
				//fFill=false;
				break;
				}
				default:
				std::cout<<"error"<<std::endl;
			}

		}//no QE details
	}//QE used
		else{

		std::cout<<" QE-NOT USED "<<std::endl;
			fFill=true;// no QE

//no qe details
		if(fDetailedQE){
			fFill=true;
			switch(fOpChannel){
				case 0:{
				//fFill=false;
				std::cout<<"breaking - channel 0 "<<std::endl;
				break;
				}
				case 1:{
				//fFill=false;
				std::cout<<"breaking - channel 1 "<<std::endl;
				break;
				}
				case 2:{
 				//fFill=false;
				break;
				}
				case 3:{
				//fFill=false;
				break;
				}
				default:
				std::cout<<"error"<<std::endl;
			}
			std::cout<<"QE not used425!!!"<<fUseQE<<std::endl;
		}//no QE details

				}
			if(fFill==true){

			 fCountOpDetDetected++;

				}
			if(fMakeDetectedPhotonsTree&&fFill==true){
				fThePhotonTreeDetected->Fill();
				std::cout<<"filling tree l. 434 "<<fOpChannel<<std::endl;
			}
				
				
			fFill=false;

		      }//wavelength cut
			
			fFill=false;
		  }//loop over simphotons
	      }//verbosity >3
	    else
	      {
    //Reset counters
   fCountOpDetAll=0;
    fCountOpDetDetected=0;

//std::cout<<"was here 381================== verbosity <3 "<<std::endl;
		for(const sim::OnePhoton& Phot: TheHit)
		  {
			//std::cout<<"detected photons reset test ---------------------- "<<fCountOpDetDetected<<" channel "<<fOpChannel<<std::endl;
			allphotons1++;
			allphotons2++;
		    // Calculate wavelength in nm
		    fWavelength= (2.0*3.142)*0.000197/Phot.Energy;
		    fTime= Phot.Time;		
    
		    // Increment per OpDet counters and fill per phot trees
		   fCountOpDetAll++;
		    fFill=false;
		    if(fMakeAllPhotonsTree) fThePhotonTreeAll->Fill();
		    if((flat.fire(1.0)<=fQE)&&(fWavelength>fWavelengthCutLow)&&(fWavelength<fWavelengthCutHigh))
		      {

	
		
		if(fUseQE){

		//std::cout<<"QE used 394!!!"<<fUseQE<<std::endl;
		if(fDetailedQE){
			fFill=true;
			switch(fOpChannel){
				case 0:{
				fftest=flat.fire(1.0);
				//std::cout<<"channel 0 etl"<<QEHmm->GetBinCenter(1)<<" "<<fftest<<" "<<QESipm->GetBinContent(QESipm->GetXaxis()->FindBin(Phot.Energy/0.000001))<<std::endl;
				if(fftest>QEEtl->GetBinContent(QESipm->GetXaxis()->FindBin(Phot.Energy/0.000001))) fFill=false;
				break;
				}
				case 1:{
				fftest=flat.fire(1.0);
				//std::cout<<"channel 1 hmm"<<std::endl;
				if(fftest>QEHmm->GetBinContent(QEHmm->GetXaxis()->FindBin(Phot.Energy/0.000001))) fFill=false;
				break;
				}
				case 2:{
				fftest=flat.fire(1.0);
				//std::cout<<"channel 2 sipm"<<std::endl;
				if(fftest>QESipm->GetBinContent(QEEtl->GetXaxis()->FindBin(Phot.Energy/0.000001))) fFill=false;
				break;
				}
				case 3:{
				fftest=flat.fire(1.0);
				//std::cout<<"channel 3 sipm"<<std::endl;
				if(fftest>QESipm->GetBinContent(QESipm->GetXaxis()->FindBin(Phot.Energy/0.000001))) fFill=false;
				break;
				}
				default:
				std::cout<<"error"<<std::endl;
			}
		

			}//QE details
		}//QE used
			else{

				std::cout<<"QE not used 509!!!"<<fUseQE<<std::endl;
				 fFill=true;//no QE used

				}
			if(fFill==true) fCountOpDetDetected++;
			if(fMakeDetectedPhotonsTree&&fFill==true) {
std::cout<<"filling tree %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% details of QE "<<fDetailedQE<<" "<<fWavelength<<std::endl;
				fThePhotonTreeDetected->Fill();
				
				}
			
			
		      }//check for passing wavelength cut
			fFill=false;
		  }//simphotons loop
	      }//verbosity <=3
	  
	  	std::cout<<"--------------------photons hitting PMTS "<<allphotons1<<" "<<allphotons2<<std::endl;      
	    // If this is a library building job, fill relevant entry
	    art::ServiceHandle<phot::PhotonVisibilityService> pvs;
	    if(pvs->IsBuildJob())
	      {
		int VoxID; double NProd;
		pvs->RetrieveLightProd(VoxID, NProd);

//change!!!!!
		pvs->SetLibraryEntry(VoxID, fOpChannel, double(fCountOpDetDetected)/NProd);		
	      }


	    // Incremenent per event and fill Per OpDet trees	    

	    fCountEventAll+=fCountOpDetAll;
	    fCountEventDetected+=fCountOpDetDetected;

	    std::cout<<"detected photons---------------------- "<<fCountOpDetDetected<<" for all event "<<fCountEventDetected<<std::endl;
		if(fMakeOpDetsTree) fTheOpDetTree->Fill();


	    // Give per OpDet output
	    if(fVerbosity >2) ;//std::cout<<"OpDetResponse PerOpDet : Event "<<fEventID<<" OpDet " << fOpChannel << " All " << fCountOpDetAll << " Det " <<fCountOpDetDetected<<std::endl; 
	  }

	// Fill per event tree
	if(fMakeOpDetEventsTree) fTheEventTree->Fill();

	// Give per event output
	if(fVerbosity >1) ;//std::cout<<"OpDetResponse PerEvent : Event "<<fEventID<<" All " << fCountOpDetAll << " Det " <<fCountOpDetDetected<<std::endl; 	

      }
    else
      {
	// if empty OpDet hit collection, 
	// add an empty record to the per event tree 
	if(fMakeOpDetEventsTree) fTheEventTree->Fill();
      }

    //Reset counters
   fCountOpDetAll=0;
    fCountOpDetDetected=0;
    
    }
    else
    {
    //Get SimPhotonsLite from Event
    art::Handle< std::vector<sim::SimPhotonsLite> > photonHandle; 
    evt.getByLabel("largeant", photonHandle);
std::cout<<"===================================================photons lite !!!!!!! "<<std::endl;
    
    //Reset counters
    fCountEventAll=0;
    fCountEventDetected=0;

    if(fVerbosity > 0) std::cout<<"Lite photons - Found OpDet hit collection of size "<< (*photonHandle).size()<<std::endl;

    
    if((*photonHandle).size()>0)
      {
        
        for ( auto const& photon : (*photonHandle) )
        {
          //Get data from HitCollection entry
          fOpChannel=photon.OpChannel;
          std::map<int, int> PhotonsMap = photon.DetectedPhotons;

          //Reset Counters
          fCountOpDetAll=0;
          fCountOpDetDetected=0;

	    if(fVerbosity > 3)
	      {
            for(auto it = PhotonsMap.begin(); it!= PhotonsMap.end(); it++)
            {
		    // Calculate wavelength in nm
		    fWavelength= 128;

		    //Get arrival time from phot
		    fTime= it->first*2;
		    std::cout<<"491 Arrival time: " << fTime<<std::endl;
		   
            for(int i = 0; i < it->second ; i++)
            {
		    // Increment per OpDet counters and fill per phot trees
		    fCountOpDetAll++;
		    if(fMakeAllPhotonsTree) fThePhotonTreeAll->Fill();
		    if((flat.fire(1.0)<=fQE)&&(fWavelength>fWavelengthCutLow)&&(fWavelength<fWavelengthCutHigh))
		      {
			if(fMakeDetectedPhotonsTree) fThePhotonTreeDetected->Fill();
			fCountOpDetDetected++;
			std::cout<<"OpDetResponse PerPhoton : Event "<<fEventID<<" OpChannel " <<fOpChannel << " Wavelength " << fWavelength << " Detected 1 "<<std::endl;
		      }
		    else;
		    //  std::cout<<"OpDetResponse PerPhoton : Event "<<fEventID<<" OpChannel " <<fOpChannel << " Wavelength " << fWavelength << " Detected 0 "<<std::endl;
            }
            }
	      }
	    else
	      {
		    for(auto it = PhotonsMap.begin(); it!= PhotonsMap.end(); it++)
            {
		      // Calculate wavelength in nm
		      fWavelength= 128;
		      fTime= it->first*2;		
   
              for(int i = 0; i < it->second; i++)
              {
                // Increment per OpDet counters and fill per phot trees
                fCountOpDetAll++;
                if(fMakeAllPhotonsTree) fThePhotonTreeAll->Fill();
                if((flat.fire(1.0)<=fQE)&&(fWavelength>fWavelengthCutLow)&&(fWavelength<fWavelengthCutHigh))
		        {
                  if(fMakeDetectedPhotonsTree) fThePhotonTreeDetected->Fill();
                  fCountOpDetDetected++;
		        }
              }
            }
          }
	  	      
	    // Incremenent per event and fill Per OpDet trees	    
	    if(fMakeOpDetsTree) fTheOpDetTree->Fill();
	    fCountEventAll+=fCountOpDetAll;
	    fCountEventDetected+=fCountOpDetDetected;

	    // Give per OpDet output
	    if(fVerbosity >2) ;//std::cout<<"OpDetResponse PerOpDet : Event "<<fEventID<<" OpDet " << fOpChannel << " All " << fCountOpDetAll << " Det " <<fCountOpDetDetected<<std::endl; 
        }
        // Fill per event tree
        if(fMakeOpDetEventsTree) fTheEventTree->Fill();

        // Give per event output
        if(fVerbosity >1) ;//std::cout<<"OpDetResponse PerEvent : Event "<<fEventID<<" All " << fCountOpDetAll << " Det " <<fCountOpDetDetected<<std::endl; 	

      }
    else
    {
      // if empty OpDet hit collection, 
      // add an empty record to the per event tree 
      if(fMakeOpDetEventsTree) fTheEventTree->Fill();
    } 
    }
//if(QEHmm) delete QEHmm;
//if(QEEtl) delete QEEtl;
//if(QeEnergyHist) delete QeEnergyHist;
//if(QESipm) delete QESipm;
  }

}


namespace opdet{

  DEFINE_ART_MODULE(SimPhotonCounter)

}//end namespace opdet
